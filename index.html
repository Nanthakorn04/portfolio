<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>Picking with Environment - Futuristic Lighting</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
</head>

<body>
    <script>
        (() => {
            // --- Scene / Camera / Renderer ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
            camera.position.set(0, 1.2, 4);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.5, 0);
            controls.enableDamping = true;
            controls.enableZoom = true;
            controls.enablePan = false;

            // --- Environment HDRI ---
            const pmremGen = new THREE.PMREMGenerator(renderer);
            pmremGen.compileEquirectangularShader();
            const exrLoader = new THREE.EXRLoader();
            exrLoader.load('https://nanthakorn04.github.io/portfolio/belfast_sunset_2k.exr', tex => {
                const envMap = pmremGen.fromEquirectangular(tex).texture;
                scene.environment = envMap;
                scene.background = envMap;
                tex.dispose();
                pmremGen.dispose();
            });

            // --- Floor ---
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = '';
            loader.load('https://nanthakorn04.github.io/portfolio/rubber_tiles_diff_2k.jpg', tex => {
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(10, 10);
                const floorMat = new THREE.MeshStandardMaterial({
                    map: tex,
                    metalness: 0.1, // ลด metalness
                    roughness: 0.8  // เพิ่ม roughness ให้สะท้อนน้อยลง
                });
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0;
                floor.receiveShadow = true;
                scene.add(floor);
            });

            // --- Objects ---
            const clickable = [];
            function addObj(mesh, pos, name) {
                mesh.position.copy(pos);
                mesh.name = name;
                scene.add(mesh);
                clickable.push(mesh);
                return mesh;
            }

            addObj(new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b, metalness: 0.2, roughness: 0.6 })
            ), new THREE.Vector3(-2, 0.4, 0), 'Box');

            addObj(new THREE.Mesh(
                new THREE.SphereGeometry(0.45, 32, 16),
                new THREE.MeshStandardMaterial({ color: 0x5dff9b, metalness: 0.2, roughness: 0.5 })
            ), new THREE.Vector3(0, 0.45, 0), 'Sphere');

            addObj(new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 24),
                new THREE.MeshStandardMaterial({ color: 0x5db6ff, metalness: 0.1, roughness: 0.6 })
            ), new THREE.Vector3(2, 0.5, 0), 'Cone');

            // --- Futuristic Lights (ลดความสว่าง) ---
            scene.add(new THREE.AmbientLight(0x220022, 0.2)); // ลด intensity

            const dirLight1 = new THREE.DirectionalLight(0x88ccff, 1);
            dirLight1.position.set(5, 10, 5);
            dirLight1.castShadow = true;
            dirLight1.shadow.mapSize.width = 2048;
            dirLight1.shadow.mapSize.height = 2048;
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xff88ff, 2);
            dirLight2.position.set(-5, 5, -5);
            scene.add(dirLight2);

            const hemiLight = new THREE.HemisphereLight(0x440044, 0x000022, 0.8);
            scene.add(hemiLight);

            // --- Preset Views ---
            const VIEWS = {
                Box: { pos: new THREE.Vector3(-3, 1.4, 1.6), tar: new THREE.Vector3(-2, 0.4, 0) },
                Sphere: { pos: new THREE.Vector3(0, 1.8, 3.0), tar: new THREE.Vector3(0, 0.45, 0) },
                Cone: { pos: new THREE.Vector3(3, 1.6, -2.0), tar: new THREE.Vector3(2, 0.5, 0) }
            };

            // --- Raycaster ---
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            function setPointer(e) {
                const r = renderer.domElement.getBoundingClientRect();
                const x = (e.clientX ?? e.touches[0].clientX) - r.left;
                const y = (e.clientY ?? e.touches[0].clientY) - r.top;
                pointer.x = (x / r.width) * 2 - 1;
                pointer.y = -(y / r.height) * 2 + 1;
            }

            let isMovingToTarget = false;
            const targetPosition = new THREE.Vector3();
            const cameraTargetPosition = new THREE.Vector3();

            function onPick(e) {
                setPointer(e);
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObjects(clickable, false)[0];
                if (!hit) return;
                const view = VIEWS[hit.object.name];
                if (!view) return;
                targetPosition.copy(view.tar);
                cameraTargetPosition.copy(view.pos);
                isMovingToTarget = true;
            }

            renderer.domElement.addEventListener('click', onPick);
            renderer.domElement.addEventListener('touchend', e => onPick(e), { passive: true });

            // --- Resize ---
            addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });

            // --- Animate ---
            function loop() {
                if (isMovingToTarget) {
                    camera.position.lerp(cameraTargetPosition, 0.03);
                    controls.target.lerp(targetPosition, 0.02);
                    if (camera.position.distanceTo(cameraTargetPosition) < 0.01 &&
                        controls.target.distanceTo(targetPosition) < 0.01) {
                        isMovingToTarget = false;
                    }
                }
                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }

            loop();
        })();
    </script>
</body>

</html>
