<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="utf-8" />
  <title>Picking with Environment - Futuristic Lighting</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
</head>

<body>
  <script>
    (() => {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
      camera.position.set(0, 5, 35); // กล้องซูมออกและสูงขึ้น

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.5, 0);
      controls.enableDamping = true;
      controls.enableZoom = true;
      controls.enablePan = true;

      const pmremGen = new THREE.PMREMGenerator(renderer);
      const exrLoader = new THREE.EXRLoader();
      exrLoader.load('https://nanthakorn04.github.io/portfolio/shanghai_bund_4k.exr', tex => {
        const envMap = pmremGen.fromEquirectangular(tex).texture;
        scene.environment = envMap;
        scene.background = envMap;
        tex.dispose();
        pmremGen.dispose();
      });

      const clickable = [];
      const gltfLoader = new THREE.GLTFLoader();
      let modelA, modelB, modelC, newModel;
      let mixers = []; // สำหรับ Animation Model C

      // โหลด Model A
      function loadModelA() {
        gltfLoader.load('https://nanthakorn04.github.io/portfolio/sen.glb', gltf => {
          modelA = gltf.scene;
          modelA.position.set(0, 0, -2);
          modelA.scale.set(1, 1, 1);
          modelA.name = 'ModelA';
          scene.add(modelA);
        });
      }

      // โหลด Model B
      function loadModelB() {
        gltfLoader.load('https://nanthakorn04.github.io/portfolio/venom.glb', gltf => {
          modelB = gltf.scene;
          modelB.position.set(0, 0, -2);
          modelB.scale.set(1, 1, 1);
          modelB.name = 'ModelB';
          scene.add(modelB);
        });
      }

      // โหลด Model C (พร้อม Animation)
      function loadModelC() {
        gltfLoader.load('https://nanthakorn04.github.io/portfolio/sp.glb', gltf => {
          modelC = gltf.scene;
          modelC.position.set(0, 0, -2);
          modelC.scale.set(1, 1, 1);
          scene.add(modelC);

          if (gltf.animations && gltf.animations.length > 0) {
            const mixer = new THREE.AnimationMixer(modelC);
            gltf.animations.forEach(clip => mixer.clipAction(clip).play());
            mixers.push(mixer);
          }
        });
      }

      // โหลดโมเดลเริ่มต้น
      loadModelA();
      loadModelB();
      loadModelC();

      // โหลดฟอนต์และสร้างปุ่ม
      const fontLoader = new THREE.FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
        const profileGeo = new THREE.TextGeometry('About', { font: font, size: 0.5, height: 0.05 });
        const profileMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 });
        const profileMesh = new THREE.Mesh(profileGeo, profileMat);
        profileGeo.computeBoundingBox();
        profileMesh.position.set(-(profileGeo.boundingBox.max.x - profileGeo.boundingBox.min.x)/2, 1.2, -1.5);
        profileMesh.name = 'NextText';
        scene.add(profileMesh);
        clickable.push(profileMesh);

        const backGeo = new THREE.TextGeometry('BACK', { font: font, size: 0.4, height: 0.05 });
        const backMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0x222222 });
        const backMesh = new THREE.Mesh(backGeo, backMat);
        backGeo.computeBoundingBox();
        backMesh.position.set(-(backGeo.boundingBox.max.x - backGeo.boundingBox.min.x)/2, 0.6, -1.5);
        backMesh.name = 'BackText';
        backMesh.visible = false;
        scene.add(backMesh);
        clickable.push(backMesh);
      });

      // แสง
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const dir1 = new THREE.DirectionalLight(0xffffff, 1.2);
      dir1.position.set(5, 10, 5);
      dir1.castShadow = true;
      scene.add(dir1);
      const dir2 = new THREE.DirectionalLight(0xffffff, 1.0);
      dir2.position.set(-5, 5, -5);
      scene.add(dir2);
      const hemi = new THREE.HemisphereLight(0x440044, 0x000022, 0.8);
      scene.add(hemi);

      // มุมกล้อง
      const VIEWS = {
        NextText: { pos: new THREE.Vector3(2.5, 1.5, 1.5), tar: new THREE.Vector3(2, 0.5, -2) },
        BackText: { pos: new THREE.Vector3(0, 2.5, 10), tar: new THREE.Vector3(0, 0.5, 0) }
      };

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function setPointer(e) {
        const r = renderer.domElement.getBoundingClientRect();
        const x = (e.clientX ?? e.touches[0].clientX) - r.left;
        const y = (e.clientY ?? e.touches[0].clientY) - r.top;
        pointer.x = (x / r.width) * 2 - 1;
        pointer.y = -(y / r.height) * 2 + 1;
      }

      let isMoving = false;
      const camTargetPos = new THREE.Vector3();
      const camTargetLook = new THREE.Vector3();

      function onPick(e) {
        setPointer(e);
        raycaster.setFromCamera(pointer, camera);
        const hit = raycaster.intersectObjects(clickable, true)[0];
        if (!hit) return;
        const name = hit.object.name;

        if (name === 'NextText') {
          if (modelA) scene.remove(modelA);
          if (modelB) scene.remove(modelB);
          if (modelC) scene.remove(modelC);

          // โหลด profile1.glb
          const loader = new THREE.GLTFLoader();
          loader.load('https://nanthakorn04.github.io/portfolio/profile1.glb', gltf => {
            newModel = gltf.scene;
            newModel.position.set(6, 0, -15);
            newModel.scale.set(1, 1, 1);
            scene.add(newModel);
          });

          hit.object.visible = false;
          const backMesh = scene.getObjectByName('BackText');
          if (backMesh) backMesh.visible = true;

          camTargetPos.copy(VIEWS.NextText.pos);
          camTargetLook.copy(VIEWS.NextText.tar);
          controls.target.copy(camTargetLook);
          isMoving = true;
        }

        if (name === 'BackText') {
          if (newModel) scene.remove(newModel);
          if (modelC) scene.remove(modelC);

          loadModelA();
          loadModelB();
          loadModelC();

          const backMesh = scene.getObjectByName('BackText');
          if (backMesh) backMesh.visible = false;

          const viewMesh = scene.getObjectByName('NextText');
          if (viewMesh) viewMesh.visible = true;

          camTargetPos.copy(VIEWS.BackText.pos);
          camTargetLook.copy(VIEWS.BackText.tar);
          controls.target.copy(camTargetLook);
          isMoving = true;
        }
      }

      renderer.domElement.addEventListener('click', onPick);
      renderer.domElement.addEventListener('touchend', e => onPick(e), { passive: true });

      addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      const clock = new THREE.Clock();

      function loop() {
        const delta = clock.getDelta();
        mixers.forEach(m => m.update(delta));

        if (isMoving) {
          camera.position.lerp(camTargetPos, 0.03);
          controls.target.lerp(camTargetLook, 0.03);
          if (camera.position.distanceTo(camTargetPos) < 0.01 &&
              controls.target.distanceTo(camTargetLook) < 0.01) {
            isMoving = false;
            controls.target.copy(camTargetLook);
          }
        }
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      loop();
    })();
  </script>
</body>

</html>
